<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Legion aims to be a feature rich high performance ECS library for Rust game projects with minimal boilerplate."><meta name="keywords" content="rust, rustlang, rust-lang, legion"><title>legion - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../legion/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../legion/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate legion</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></div></section><div id="sidebar-vars" data-name="legion" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../legion/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">legion</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/legion/lib.rs.html#1-214">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Legion aims to be a feature rich high performance ECS library for Rust game projects with minimal boilerplate.</p>
<h2 id="getting-started"><a href="#getting-started">Getting Started</a></h2><h3 id="worlds"><a href="#worlds">Worlds</a></h3>
<p><a href="world/struct.World.html">Worlds</a> are collections of <a href="world/struct.Entity.html">entities</a>, where each entity can have an arbitrary collection of
<a href="storage/trait.Component.html">components</a> attached.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">legion</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="ident">world</span> <span class="op">=</span> <span class="ident">World::default</span>();</code></pre></div>
<p>Entities can be inserted via either <a href="world/struct.World.html#method.push" title="World::push"><code>World::push</code></a> (for a single entity) or <a href="world/struct.World.html#method.extend" title="World::extend"><code>World::extend</code></a> (for a collection
of entities with the same component types). The world will create a unique ID for each entity upon insertion
that you can use to refer to that entity later.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// a component is any type that is &#39;static, sized, send and sync</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Position</span> {
    <span class="ident">x</span>: <span class="ident">f32</span>,
    <span class="ident">y</span>: <span class="ident">f32</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Velocity</span> {
    <span class="ident">dx</span>: <span class="ident">f32</span>,
    <span class="ident">dy</span>: <span class="ident">f32</span>,
}

<span class="comment">// push a component tuple into the world to create an entity</span>
<span class="kw">let</span> <span class="ident">entity</span>: <span class="ident">Entity</span> <span class="op">=</span> <span class="ident">world</span>.<span class="ident">push</span>((<span class="ident">Position</span> { <span class="ident">x</span>: <span class="number">0.0</span>, <span class="ident">y</span>: <span class="number">0.0</span> }, <span class="ident">Velocity</span> { <span class="ident">dx</span>: <span class="number">0.0</span>, <span class="ident">dy</span>: <span class="number">0.0</span> }));

<span class="comment">// or extend via an IntoIterator of tuples to add many at once (this is faster)</span>
<span class="kw">let</span> <span class="ident">entities</span>: <span class="kw-2">&amp;</span>[<span class="ident">Entity</span>] <span class="op">=</span> <span class="ident">world</span>.<span class="ident">extend</span>(<span class="macro">vec!</span>[
    (<span class="ident">Position</span> { <span class="ident">x</span>: <span class="number">0.0</span>, <span class="ident">y</span>: <span class="number">0.0</span> }, <span class="ident">Velocity</span> { <span class="ident">dx</span>: <span class="number">0.0</span>, <span class="ident">dy</span>: <span class="number">0.0</span> }),
    (<span class="ident">Position</span> { <span class="ident">x</span>: <span class="number">1.0</span>, <span class="ident">y</span>: <span class="number">1.0</span> }, <span class="ident">Velocity</span> { <span class="ident">dx</span>: <span class="number">0.0</span>, <span class="ident">dy</span>: <span class="number">0.0</span> }),
    (<span class="ident">Position</span> { <span class="ident">x</span>: <span class="number">2.0</span>, <span class="ident">y</span>: <span class="number">2.0</span> }, <span class="ident">Velocity</span> { <span class="ident">dx</span>: <span class="number">0.0</span>, <span class="ident">dy</span>: <span class="number">0.0</span> }),
]);</code></pre></div>
<p>You can access entities via <a href="world/struct.Entry.html">entries</a>. Entries allow you to query an entity to find out what
types of components are attached to it, to get component references, or to add and remove components.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// entries return `None` if the entity does not exist</span>
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">entry</span>) <span class="op">=</span> <span class="ident">world</span>.<span class="ident">entry</span>(<span class="ident">entity</span>) {
    <span class="comment">// access information about the entity&#39;s archetype</span>
    <span class="macro">println!</span>(
        <span class="string">&quot;{:?} has {:?}&quot;</span>,
        <span class="ident">entity</span>,
        <span class="ident">entry</span>.<span class="ident">archetype</span>().<span class="ident">layout</span>().<span class="ident">component_types</span>()
    );

    <span class="comment">// add an extra component</span>
    <span class="ident">entry</span>.<span class="ident">add_component</span>(<span class="number">12f32</span>);

    <span class="comment">// access the entity&#39;s components, returns `None` if the entity does not have the component</span>
    <span class="macro">assert_eq!</span>(<span class="ident">entry</span>.<span class="ident">get_component</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="number">12f32</span>);
}</code></pre></div>
<p>See the <a href="world/index.html" title="world"><code>world</code></a> module for more information.</p>
<h3 id="queries"><a href="#queries">Queries</a></h3>
<p>Entries are not the most convenient or performant way to search or bulk-access a world. <a href="query/index.html">Queries</a>
allow for high performance and expressive iteration through the entities in a world.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// you define a query be declaring what components you want to find, and how you will access them</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="ident">Read</span>::<span class="op">&lt;</span><span class="ident">Position</span><span class="op">&gt;</span><span class="ident">::query</span>();

<span class="comment">// you can then iterate through the components found in the world</span>
<span class="kw">for</span> <span class="ident">position</span> <span class="kw">in</span> <span class="ident">query</span>.<span class="ident">iter</span>(<span class="kw-2">&amp;</span><span class="ident">world</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">position</span>);
}</code></pre></div>
<p>You can search for entities which have all of a set of components.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// construct a query from a &quot;view tuple&quot;</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="ident">Velocity</span>, <span class="kw-2">&amp;mut</span> <span class="ident">Position</span>)<span class="op">&gt;</span><span class="ident">::query</span>();

<span class="comment">// this time we have &amp;Velocity and &amp;mut Position</span>
<span class="kw">for</span> (<span class="ident">velocity</span>, <span class="ident">position</span>) <span class="kw">in</span> <span class="ident">query</span>.<span class="ident">iter_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">world</span>) {
    <span class="ident">position</span>.<span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="ident">velocity</span>.<span class="ident">x</span>;
    <span class="ident">position</span>.<span class="ident">y</span> <span class="op">+</span><span class="op">=</span> <span class="ident">velocity</span>.<span class="ident">y</span>;
}</code></pre></div>
<p>You can augment a basic query with additional filters. For example, you can choose to exclude
entities which also have a certain component, or only include entities for which a certain
component has changed since the last time the query ran (this filtering is conservative and coarse-grained)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// you can use boolean expressions when adding filters</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="ident">Velocity</span>, <span class="kw-2">&amp;mut</span> <span class="ident">Position</span>)<span class="op">&gt;</span><span class="ident">::query</span>()
    .<span class="ident">filter</span>(<span class="op">!</span><span class="ident">component</span>::<span class="op">&lt;</span><span class="ident">Ignore</span><span class="op">&gt;</span>() <span class="op">&amp;</span> <span class="ident">maybe_changed</span>::<span class="op">&lt;</span><span class="ident">Position</span><span class="op">&gt;</span>());

<span class="kw">for</span> (<span class="ident">velocity</span>, <span class="ident">position</span>) <span class="kw">in</span> <span class="ident">query</span>.<span class="ident">iter_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">world</span>) {
    <span class="ident">position</span>.<span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="ident">velocity</span>.<span class="ident">dx</span>;
    <span class="ident">position</span>.<span class="ident">y</span> <span class="op">+</span><span class="op">=</span> <span class="ident">velocity</span>.<span class="ident">dy</span>;
}</code></pre></div>
<p>There is much more than can be done with queries. See the <a href="query/index.html">module document</a> for more information.</p>
<h3 id="systems"><a href="#systems">Systems</a></h3>
<p>You may have noticed that when we wanted to write to a component, we needed to use <code>iter_mut</code> to iterate through our query.
But perhaps your application wants to be able to process different components on different entities, perhaps even at the same
time in parallel? While it is possible to do this manually (see <a href="world/struct.World.html#method.split" title="World::split"><code>World::split</code></a>), this is very difficult to do when the
different pieces of the application don’t know what components each other need, or might or might not even have conflicting
access requirements.</p>
<p>Systems and the <a href="systems/struct.Schedule.html" title="Schedule"><code>Schedule</code></a> automates this process, and can even schedule work at a more granular level than
you can otherwise do manually.</p>
<p>A system is a unit of work. Each system is defined as a function which is provided access to queries and shared
<a href="systems/struct.Resources.html" title="Resources"><code>Resources</code></a>. These systems can then be appended to a schedule, which is a linear sequence of systems,
ordered by when side effects (such as writes to components) should be observed.</p>
<p>The schedule will automatically parallelize the execution of all systems whilst maintaining the apparent order of execution from
the perspective of each system.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// a system fn which loops through Position and Velocity components, and reads</span>
<span class="comment">// the Time shared resource.</span>
<span class="attribute">#[<span class="ident">system</span>(<span class="ident">for_each</span>)]</span>
<span class="kw">fn</span> <span class="ident">update_positions</span>(<span class="ident">pos</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Position</span>, <span class="ident">vel</span>: <span class="kw-2">&amp;</span><span class="ident">Velocity</span>, <span class="attribute">#[<span class="ident">resource</span>]</span> <span class="ident">time</span>: <span class="kw-2">&amp;</span><span class="ident">Time</span>) {
    <span class="ident">pos</span>.<span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="ident">vel</span>.<span class="ident">dx</span> <span class="op">*</span> <span class="ident">time</span>.<span class="ident">elapsed_seconds</span>;
    <span class="ident">pos</span>.<span class="ident">y</span> <span class="op">+</span><span class="op">=</span> <span class="ident">vel</span>.<span class="ident">dy</span> <span class="op">*</span> <span class="ident">time</span>.<span class="ident">elapsed_seconds</span>;
}

<span class="comment">// construct a schedule (you should do this on init)</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">schedule</span> <span class="op">=</span> <span class="ident">Schedule::builder</span>()
    .<span class="ident">add_system</span>(<span class="ident">update_positions_system</span>())
    .<span class="ident">build</span>();

<span class="comment">// run our schedule (you should do this each update)</span>
<span class="ident">schedule</span>.<span class="ident">execute</span>(<span class="kw-2">&amp;mut</span> <span class="ident">world</span>, <span class="kw-2">&amp;mut</span> <span class="ident">resources</span>);</code></pre></div>
<p>See the <a href="systems/index.html" title="systems"><code>systems</code></a> module and the <a href="attr.system.html" title="system"><code>system</code></a> proc macro for more information.</p>
<h2 id="feature-flags"><a href="#feature-flags">Feature Flags</a></h2>
<p>Legion provides a few feature flags:</p>
<ul>
<li><code>parallel</code> - Enables parallel iterators and parallel schedule execution via the rayon library. Enabled by default.</li>
<li><code>extended-tuple-impls</code> - Extends the maximum size of view and component tuples from 8 to 24, at the cost of increased compile times. Off by default.</li>
<li><code>serialize</code> - Enables the serde serialization module and associated functionality. Enabled by default.</li>
<li><code>crossbeam-events</code> - Implements the <code>EventSender</code> trait for crossbeam <code>Sender</code> channels, allowing them to be used for event subscriptions. Enabled by default.</li>
<li><code>codegen</code> - Enables the <code>#[system]</code> procedural macro. Enabled by default.</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="query/index.html" title="legion::query mod">query</a></div><div class="item-right docblock-short"><p>Queries provide efficient iteration and filtering of entity components in a world.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="serialize/index.html" title="legion::serialize mod">serialize</a></div><div class="item-right docblock-short"><p>Serde (de)serialization of worlds.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="storage/index.html" title="legion::storage mod">storage</a></div><div class="item-right docblock-short"><p>A “packed archetype” storage model.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="systems/index.html" title="legion::systems mod">systems</a></div><div class="item-right docblock-short"><p>Automatic query scheduling and parallel execution.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="world/index.html" title="legion::world mod">world</a></div><div class="item-right docblock-short"><p>Worlds store collections of entities. An entity is a collection of components, identified
by a unique <a href="world/struct.Entity.html" title="Entity"><code>Entity</code></a> ID.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Entity.html" title="legion::Entity struct">Entity</a></div><div class="item-right docblock-short"><p>An opaque identifier for an entity.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Query.html" title="legion::Query struct">Query</a></div><div class="item-right docblock-short"><p>Provides efficient means to iterate and filter entities in a world.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Read.html" title="legion::Read struct">Read</a></div><div class="item-right docblock-short"><p>Reads a single entity data component type from a chunk.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Registry.html" title="legion::Registry struct">Registry</a></div><div class="item-right docblock-short"><p>A world (de)serializer which describes how to (de)serialize the component types in a world.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Resources.html" title="legion::Resources struct">Resources</a></div><div class="item-right docblock-short"><p>Resources container. Shared resources stored here can be retrieved in systems.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Schedule.html" title="legion::Schedule struct">Schedule</a></div><div class="item-right docblock-short"><p>A schedule of systems for execution.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SystemBuilder.html" title="legion::SystemBuilder struct">SystemBuilder</a></div><div class="item-right docblock-short"><p>A low level builder for constructing systems.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TryRead.html" title="legion::TryRead struct">TryRead</a></div><div class="item-right docblock-short"><p>Reads a single entity data component type from a chunk.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TryWrite.html" title="legion::TryWrite struct">TryWrite</a></div><div class="item-right docblock-short"><p>Writes a single entity data component type from a chunk.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.World.html" title="legion::World struct">World</a></div><div class="item-right docblock-short"><p>A container of entities.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WorldOptions.html" title="legion::WorldOptions struct">WorldOptions</a></div><div class="item-right docblock-short"><p>Describes configuration options for the creation of a new <a href="world/struct.World.html" title="World"><code>World</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Write.html" title="legion::Write struct">Write</a></div><div class="item-right docblock-short"><p>Writes a single mutable entity data component type from a chunk.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EntityStore.html" title="legion::EntityStore trait">EntityStore</a></div><div class="item-right docblock-short"><p>The <code>EntityStore</code> trait abstracts access to entity data as required by queries for
both <a href="world/struct.World.html" title="World"><code>World</code></a> and <a href="world/struct.SubWorld.html" title="SubWorld"><code>SubWorld</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Fetch.html" title="legion::Fetch trait">Fetch</a></div><div class="item-right docblock-short"><p>A type which holds onto a slice of entity data retrieved from a single archetype.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GroupSource.html" title="legion::GroupSource trait">GroupSource</a></div><div class="item-right docblock-short"><p>A type which defines a component group.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoQuery.html" title="legion::IntoQuery trait">IntoQuery</a></div><div class="item-right docblock-short"><p>A type (typically a view) which can construct a query.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoSoa.html" title="legion::IntoSoa trait">IntoSoa</a></div><div class="item-right docblock-short"><p>Describes a type which can convert itself into an SoA representation for entity insertion.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.any.html" title="legion::any fn">any</a></div><div class="item-right docblock-short"><p>Constructs a filter which passes all entities.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.component.html" title="legion::component fn">component</a></div><div class="item-right docblock-short"><p>Constructs a filter which requires that the entities have the given component.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.maybe_changed.html" title="legion::maybe_changed fn">maybe_changed</a></div><div class="item-right docblock-short"><p>Constructs a filter which requires that the component cannot be certain to have not changed.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.passthrough.html" title="legion::passthrough fn">passthrough</a></div><div class="item-right docblock-short"><p>Constructs a filter which performs a no-op and defers to any filters it is combined with.</p>
</div></div></div><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.system.html" title="legion::system attr">system</a></div><div class="item-right docblock-short"><p>Wraps a function in a system, and generates a new function which constructs that system.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="legion" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0-nightly (10cc7a6d0 2022-02-26)" ></div>
</body></html>