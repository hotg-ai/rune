#![no_std]
#![feature(alloc_error_handler)]
#![allow(warnings)]

extern crate alloc;
extern crate wee_alloc;

use wee_alloc::WeeAlloc;

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

static mut PRINT_BUF: [u8; 512] = [0 as u8; 512];

extern "C" {
    fn tfm_model_invoke(feature_idx: *const u8, feature_len: u32) -> u32;

    fn tfm_preload_model(
        model_idx: *const u8,
        model_len: u32,
        inputs: u32,
        outputs: u32,
    ) -> u32;

    fn _debug(str_ptr: *const u8, str_len: u32) -> u32;

    fn request_capability(ct: u32) -> u32;

    fn request_capability_set_param(
        idx: u32,
        key_str_ptr: *const u8,
        key_str_len: u32,
        value_ptr: *const u8,
        value_len: u32,
        value_type: u32,
    ) -> u32;

    fn request_manifest_output(t: u32) -> u32;

    fn request_provider_response(
        provider_response_idx: *const u8,
        max_allowed_provider_response: u32,
        capability_idx: u32,
    ) -> u32;
}

static mut DEBUG_BUFFER: [u8; 1024] = [0; 1024];

struct DebugWriter<'buf> {
    buffer: &'buf mut [u8],
    bytes_written: usize,
}

impl<'buf> DebugWriter<'buf> {
    fn written(&self) -> &[u8] { &self.buffer[..self.bytes_written] }

    fn rest(&mut self) -> &mut [u8] { &mut self.buffer[self.bytes_written..] }

    fn flush(&mut self) {
        let msg = self.written();

        unsafe {
            _debug(msg.as_ptr(), msg.len() as u32);
        }

        self.bytes_written = 0;
    }
}

impl<'buf> core::fmt::Write for DebugWriter<'buf> {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        let rest = self.rest();

        if rest.len() < s.len() {
            return Err(core::fmt::Error);
        }

        rest[..s.len()].copy_from_slice(s.as_bytes());

        Ok(())
    }
}

macro_rules! debug {
    ($fmt:literal $(, $arg:expr)*) => {
        {
            use core::fmt::Write as _;
            // SAFETY: The WebAssembly will only ever be used by a single thread
            // at a time.
            unsafe {
                let mut buffer = DebugWriter { buffer: &mut DEBUG_BUFFER, bytes_written: 0 };

                if write!(buffer, $fmt, $($arg),*).is_ok() {
                    buffer.flush();
                }
            }
        }
    };
}

#[panic_handler]
fn on_panic(info: &core::panic::PanicInfo) -> ! {
    debug!("Panic {}", info);

    unsafe { core::arch::wasm32::unreachable() }
}

#[alloc_error_handler]
fn on_alloc_error(layout: core::alloc::Layout) -> ! {
    panic!("memory allocation of {} bytes failed", layout.size())
}

#[no_mangle]
pub extern "C" fn _manifest() -> u32 {
    unsafe {
        {{~#each models}}
        let {{this}}_model = include_bytes!("{{this}}.tflite");
        tfm_preload_model(
            {{this}}_model.as_ptr(),
            {{this}}_model.len() as u32,
            1,
            1,
        );
        {{~ /each}}

        {{#each capabilities}}
        let ix = request_capability(runic_types::CAPABILITY::{{kind}} as u32);
        {{#each parameters}}
        let key = "{{@key}}";
        let value = u32::to_be_bytes({{this}});
        request_capability_set_param(
            ix,
            key.as_ptr(),
            key.len() as u32,
            value.as_ptr(),
            value.len() as u32,
            runic_types::PARAM_TYPE::INT as u32,
        );
        {{~/each}}
        {{~/each}}

        {{~#each outputs}}
        request_manifest_output(runic_types::OUTPUT::{{this}} as u32);
        {{~/each}}
    }

    1
}

#[no_mangle]
pub extern "C" fn _call(
    capability_type: i32,
    input_type: i32,
    capability_idx: i32,
) -> i32 {
    static mut BUFFER: [u8; 512] = [0; 512];

    unsafe {
        let response_size = request_provider_response(
            BUFFER.as_ptr(),
            BUFFER.len() as u32,
            capability_idx as u32,
        );

        if response_size > 0 {
            //debug(b"Have a response\r\n");
            let response_size = response_size as usize;
            let buf: &[u8] = &BUFFER[..response_size];
            let proc_block_output = buf;

            if input_type == runic_types::PARAM_TYPE::FLOAT as i32 {
                if capability_type == runic_types::CAPABILITY::RAND as i32 {
                    tfm_model_invoke(
                        proc_block_output.as_ptr() as *const u8,
                        proc_block_output.len() as u32,
                    );
                    return proc_block_output.len() as i32;
                }
            }
        }

        response_size as i32
    }
}
